---
layout: post
title: Medium - Designing very large (JavaScript) applications
description: >
  <a href="https://medium.com/@cramforce/designing-very-large-javascript-applications-6e013a3291a3"> 원문 - Malte Ubl </a>
author: author
comments: true
---

Trend 파악을 위한 Medium 기고문 포스팅 - 자바스크립트로 굉장히 큰 응용프로그램을 설계하는 것

<a href="https://www.industrialempathy.com/posts/designing-very-large-javascript-applications/">원 게시물은 제 블로그에 Industrial Empathy에 있습니다.</a>

이 내용은 제가 호주 JSConf에서 발표했던 내용을 수정한 것입니다. <a href="https://www.youtube.com/watch?v=ZZmUwXEiPm4">유튜브에서 전체 발표를 들으실 수 있습니다.</a>

<center>
<img src="https://miro.medium.com/max/700/1*DqvlkOgHSKmp5Tu1eX5mdw.png"/>
Slide text: Hello, I used to build very large JavaScript applications.
:.figure
</center>


반갑습니다 여러분. 저는 아주아주 큰 자바스크립트 응용프로그램을 만들었습니다. 정말로 다시는 하고 싶지 않습니다. 저는 해당 업무를 하면서 제가 배우게 된 것을 다시 떠올리며 공유를 하는 것이 좋을 것이라고 생각했습니다. 어제 컨퍼런스 네트워크 타임에서 저는 맥주를 마시다가 이런 질문을 받았습니다. "Malte씨, 만약 당신에게 기회가 주어진다면 어떤 것에 대해 말씀하고 싶으신가요?" 그리고 그에대한 대답을 저는 이 발표에서 하려고 합니다. 저는 구글에서 자바스크립트 프레임워크를 만들었습니다. 해당 프레임워크는 Photos, Plus, Drive, Play, 그리고 검색엔진에 사용되었습니다. 이것중에 몇몇은 꽤 큰 서비스죠, 아마 여러분들 중에 써보신 분들도 있을 겁니다.

<center>
<img src="https://miro.medium.com/max/700/1*v0r4OVf-RXr9ePakdmv5LQ.png"/>
Slide text: I thought React was good.
:.figure
</center>


이 자바스크립트 프레임워크는 오픈 소스가 아니었습니다. 왜 오픈소스가 아니었냐 하면 리액트와 비슷한 시기에 나왔기 때문에 "사람들이 또 다른 JS 프레임워크가 필요할까?" 하는 생각이었기 때문이죠. 구글은 이미 그때 앵귤러, 폴리미어와 같은 것들이 있었고 다른 사람들에게는 여러개가 있는 것이 혼란스러울 것이기 때문에 저는 그냥 우리 사내에서 쓰는 것으로 결정했습니다. 게다가 오픈소스가 아니었기 때문에 우리가 개발하면서 알게된 것을 공유하는 것이 더욱 가치 있다고 생각한 것입니다.

<center>
<img src="https://miro.medium.com/max/700/1*LL3uYYDMT5uIFRxR_7JxPQ.png"/>
Picture of lots of people.
:.figure
</center>


자 그럼 아주 큰 응용프로그램들이 공통적으로 가지고 있는 것에 대해 얘기해 봅시다. 아마 거기에는 많은 개발자들이 있을 겁니다. 몇십명일 수도 있고 그보다 더 많은 사람들일 수도 있습니다. 이들은 모두 감정이 있고 대인관계의 문제가 있을 수 있습니다. 여러분이 그럴 수도 있겠죠.

<center>
<img src="https://miro.medium.com/max/700/1*WEH24kaBbar8-1gzN_AO3w.png"/>
Picture of very old building.
:.figure
</center>


그리고 여러분의 팀이 그렇게 크지 않더라도 여러분은 잠시동안 일을 할 수도 있고 유지보수를 하는 첫 사람이 아닐 수도 있으며 모든 컨텍스트가 없을 수도 있고 여러분이 이해하지 못하는 것이 있을 수 있으며 여러분의 팀에는 응용프로그램에 대해 전혀 이해하지 못하는 사람이 있을 수 있습니다. 이러한 요소들이 우리가 매우 큰 응용프로그램을 만들 때 생각해야 하는 것입니다.

<center>
<img src="https://miro.medium.com/max/700/1*fzb42X35lNGmkQHhJLhEBQ.png"/>
Tweet saying: A team of senior engineers without junior engineers is a team of engineers.
:.figure
</center>


제가 이 자리에서 여러분들에게 알려드리고 싶은 다른 한가지는 약간은 우리의 커리어에 대한 관점에서 본 것입니다. 아마 우리 중 대다수는 스스로를 시니어 엔지니어라고 생각하거나 그정도는 아니지만 시니어 개발자가 되고 싶을 겁니다. 제가 생각하는 시니어 엔지니어는 다른 사람이 내게 물어보는 모든 문제를 거의 해결할 수 있는 것입니다. 저는 제가 쓰는 도구들을 정확히 할고 도메인 또한 알고 있습니다. 그리고 시니어 개발자의 또다른 중요한 점은 주니어 엔지니어들을 결국에는 시니어 엔지니어로 만들어야 한다는 것입니다.

<center>
<img src="https://miro.medium.com/max/700/1*xpRJ1dXHMlFq1V4oDKU__w.png"/>
Slide text: Junior -> Senior -> ?
:.figure
</center>


자 그럼 시니어 개발자의 다음은 무엇일까요? 선임 개발자의 단계가 되면 그다음은 뭘해야 할까요? 누군가는 매니지먼트라고 할 수도 있겠지만 모두에게 맞는 대답은 아닐겁니다. 모두가 관리자가 되고 싶은건 아니니까요. 그렇지 않나요? 아마 우리중 누군가는 정말로 엄청난 엔지니어가 될거고 우리도 그런 엔지니어가 되지 말란법은 없잖아요?

<center>
<img src="https://miro.medium.com/max/700/1*wL5wiTWICj1keue9YZOAhQ.png"/>
Slide text: “I know how I would solve the problem”
:.figure
</center>


저는 시니어 레벨 그 다음으로 올라가는 방법을 제안하려고 합니다. 그 방법은 제가 시니어 개발자일 때 스스로에게 했던 말로 " 난 그문제를 어떻게 푸는지 알아 " 였습니다. 제가 문제를 어떻게 푸는지 알았기 때문에 다른 사람도 가르칠 수 있었던 거죠.

<center>
<img src="https://miro.medium.com/max/700/1*UyLoKH7y54JAYigVlwCJpQ.png"/>
Slide text: “I know how others would solve the problem”
:.figure
</center>


그리고 다음 레벨에 대한 제 이론은 스스로에게 " 난 다른사람들이 그 문제를 어떻게 풀었는지 알아 " 라는 것입니다.

<center>
<img src="https://miro.medium.com/max/700/1*zBBGLRIZw94gp54pspvx-g.png"/>
Slide text: “I can anticipate how API choices and abstractions impact the way other people would solve the problem.”
:.figure
</center>


좀 더 구체적으로 말해보겠습니다. "내가 결정한 API 선택이나 프로젝트 추상화와 같은 것들이 다른 사람들에게 어떻게 영향을 미치고 그들이 어떻게 문제를 해결할지 예측할 수 있다" 입니다.
응용프로그램에서 제가 하는 선택들이 어떤 영향을 미치는지 안다는 것은 매우 강력한 개념입니다.

<center>
<img src="https://miro.medium.com/max/700/1*LnDv6Ry0Hq2MaQEARaD8rg.png"/>
Slide text: An application of empathy.
:.figure
</center>


저는 이것을 어플리케이션 공감이라고 정의하고 싶습니다. 다른 소프트웨어 엔지니어들에 대한 여러분의 생각과 여러분이 어떻게 해야할지, 여러분이 API를 전달해주면 그들이 어떻게 영향을 받고 소프트웨어를 작성할지 예상을 하는 것이죠.

<center>
<img src="https://miro.medium.com/max/700/1*pnYiZTAfQqsbeS7kVkLe_g.png"/>
</center>

어플리케이션에 대한 공감은 쉬운 것입니다. 일반적인 공감은 아주아주 어렵죠. 그래도 여러분이 공감을 해야하는 사람은 소프트웨어 엔지니어 들입니다. 여러분들과 다른 점이 있겠지만 그래도 소프트웨어를 만드는 것에 대한 일반적인 상식이 있습니다. 이런 종류의 공감능력은 여러분이 경험을 쌓을 수록 더욱 개선될 것입니다.

<center>
<img src="https://miro.medium.com/max/700/1*Op0wLWIqwZ-A5iSuWrqtKA.png"/>
Slide text: Programming model
:.figure
</center>


이런 주제에 대해서 예기할 때 가장 중요한 용어가 바로 프로그래밍 모델 입니다. 저는 실제로도 굉장히 많이 쓰고 있죠. 프로그래밍 모델은 "주어진 API 집합, 라이브러리, 프레임워크, 툴 사용법에 대한 소프트웨어 도큐먼트" 들입니다. 그리고 제가 말씀드리는 것의 진짜 의미는 API들을 미묘하게 바꾸면 그러한 프로그래밍 모델에 어떤 영향을 미치게 될까 하는 것이죠.

<center>
<img src="https://miro.medium.com/max/700/1*zuLA-tH9b8k4i1yfKMScmA.png"/>
Slide text: Programming model impact examples: React, Preact, Redux, Date picker from npm
:.figure
</center>


이러한 프로그래밍 모델에 영향을 미치는 것에 대한 예시들을 보여드리겠습니다. 여러분이 앵귤러 프로젝트를 가지고 있다고 해봅시다. 그리고 " 저는 이걸 리액트로 바꿀겁니다 " 라고 말했다고 해보죠. 이것은 명백하게 사람들이 코딩하는 방법을 바꿀겁니다. 그렇죠? 그러나 여러분이 만약 " 가상 돔이 60KB 정도 데이터 멍잉 (맵핑) 되어야 합니다. Preact로 스위치 하시죠 ". 이것은 API 호환성 라이브러리이기 때문에 사람들이 코딩을 하는데 변화를 주지 않을 것입니다. 여러분이 그런 선택을 했기 때문이죠. 그리고 나서 여러분들은 아마도 이렇게 말할지 모릅니다. " 이것은 매우 복잡합니다. 응용프로그램이 어떻게 동작하는지 관리하는 게 있어야 하기 대문에 Redux를 알려드리겠습니다. " 이렇게 되면 사람들은 코딩하는 방식을 바꿔야 하죠. 여러분은 그리고 나서 이런 요구를 받는 겁니다. " 데이터 피커가 필요해요 ", 여러분은 npm으로 가서 검색을 합니다. 500개 중에서 하나를 선택합니다. 여러분이 뭘 선택하는지가 중요할까요? 데이터 피커를 고르는 것 때문에 여러분이 코딩하는 방식을 바꾸고 싶지 않을 것입니다. 그러나 방대한 모듈들이 있는 npm을 사용한다는 것은 결국 여러분이 코딩하는 방식을 바꾸게 되죠. 물론 이런 것들은 사람들이 소프트웨어를 작성하는 방식에 영향을 주는 아주 작은 예제들 중 하나입니다.

<center>
<img src="https://miro.medium.com/max/700/1*KfcGnWC3WcwBqGYLPiybgw.png"/>
Slide text: Code splitting
:.figure
</center>


큰 자바스크립트 응용프로그램들이 공통적으로 가지고 있는 특성 중에서 제가 말하고 싶은 것은 바로 여러분들이 유저에게 배포할 때 입니다. 너무나 크기 때문에 유저에게 한번에 전달되지 않는 것 말이죠. 여기에 필요한 것이 코드 분할입니다. 코드 분할의 의미는 여러분의 응용프로그램을 번들의 집합으로 정의하는 것이죠. 그러니까 이런 겁니다. "어떤 유저는 우리 앱의 한 부분만 사용하고 다른 유저는 또 다른 부분을 사용합니다" 그렇기 때문에 여러분의 프로그램을 번들로 만들어놓고 유저가 실제로 실행하는 부분만 다운로드 하게 하는 것이죠. 이것은 여기있는 우리 모두가 할 수 있는겁니다. 최소한 자바스크립트 환경에서는 많은 것들이 클로저 컴파일러로 개발 된 것 처럼 말이죠. 그러나 제가 생각하는 코드 분할의 가장 대중적인 방식은 웹팩을 이용한 것입니다. 그리고 이게 진짜 쩌는게 RollupJS에서 최근부터 지원하기 시작했습니다. 여러분들 모두개 하시면 좋은 거지만 이 어플리케이션을 사용하는 것에는 심사숙고를 하셔야 합니다.
왜냐면 프로그래밍 모델에 영향을 주고 코딩하는 방식이 달라져야 하기 때문이죠.

<center>
<img src="https://miro.medium.com/max/700/1*vAR8HCbwiwX8bVa0xIsk6g.png"/>
Slide text: Static -> Dynanic
:.figure
</center>


여러분들은 동기로 쓰고 있던 것들을 비동기로 바꾸셨을 겁니다. 코드 분할을 안쓰면 여러분의 코드는 간단하고 좋을 겁니다. 이게 중요합니다. 잘 동작하고 안정적이고 여러분들이 기다릴 필요가 없죠. 코드분할은 가끔씩 " 아.. 저 번들이 필요하군 " 이라고 할 때가 옵니다. 그러면 네트워크로 가야하고 이러한 상황이 발생한다는 것이 응용프로그램을 더욱 복잡하게 만드는 것입니다.

<center>
<img src="https://miro.medium.com/max/700/1*DqT7As1rm_M9cxyW1RIW6w.png"/>
Slide text: Human
:.figure
</center>

그리고 팀에는 IT 업계에 막 들어온 사람도 있습니다. 여러분이 코드 분할을 하면 번들을 정의해야 하고 그것은 언제 그것들을 로딩해야할지 정행야 하기 때문ㅇ에 여러분의 팀에 주닝어들ㅇ은 언제 어떤 번들이 로딩됭어야 할지 결정해야 되는 것이죠. 항상 사람이 연관될 때마다 프로그래밍 모델에 어떤 영향이 가는지 생각해야 합니다. 왜냐면 팀원들이 고려해야 하는 것이니까요.

<center>
<img src="https://miro.medium.com/max/1400/1*0jNa8A5ciY6pCJCN65vLiA.png"/>
Slide text: Route based code splitting
:.figure
</center>

이 문제를 해결하기 위한 탄탄한 방법이 있는데 그것은 코드 스플릿팅을 할 때 라우트 기반으로 코드 분할을 하는 것입니다. 여러분이 아직 코드 분할을 하지 않았다면 여러분이 처음으로 해보셔야 할 방법입니다. Routes는 여러분 어플리케이션의 URL 베이스라인 구조입니다. 예를들어 `/product/` 페이지나 카테고리 페이지들이 있을 수 있죠. 여러분은 각 라우트 마다 번들을 하나씩 만들면 되는 것입니다. 그래서 유저들이 해당 경로로 갈 때마다 라우터에서 연관된 번들을 로딩하고 해당 경로 내에서는 여러분은 코드 분할에 대해서 더 이상 고려하지 않으셔도 되는 것입니다. 이제 프로그래밍 모델로 돌아가자면 거의 모든 것을 가지고 있는 하나의 번들과 비슷합니다. 굉장히 좋은 접근법이기 때문에 코드 분할을 시도하신다면 이 방법으로 해보시는 것을 추천 드립니다.

그러나 이 타이틀처럼 ** 아주 ** 큰 자바스크립트 응용프로그램의 경우 경로마다 번들을 만들더라도 굉장히 번들이 크게 되고 그 자체로 크기 때문에 코드 분할을 또 해야할 수도 있습니다. 실제로 이렇게 큰 응용프로그램의 예시를 보여드리죠.

<center>
<img src="https://miro.medium.com/max/1400/1*ox94bGuhxWXE-OubL7St6w.png"/>
Google Search query screenshot for “public speaking 101”
:.figure
</center>

저는 이런 컨퍼런스의 발표자로 신청하는 법을 알아보려고 했었고 위와 같은 링크들을 확인할 수 있었습니다. 여러분은 이 페이지를 하나의 라우트 번들로 만드는 것을 생각해보실 수 있으실 겁니다.

<center>
<img src="https://miro.medium.com/max/700/1*P-XiIPnuzq9_KLA1nG-uRA.png"/>
Google Search query screenshot for “weath”
:.figure
</center>

그러나 제가 캘리포니아의 겨울 날씨를 알아보려고 할 때는 완전 다른 모듈이 쓰에기 도리겁니다. 그러니까 간단하게 보이는 라우트도 사실은 우리 생각보다 더욱 복잡한거죠.

<center>
<img src="https://miro.medium.com/max/700/1*Y7e5LoeBggY01aRkJAiwWA.png"/>
</center>
Google Search query screenshot for “20 usd to aud”
:.figure

그리고 제가 이 컨퍼런스에 초대받았을 때 저는 달러와 호주달러의 환율에 대해서 체크하려고 했고 그렇게 하면 라우트 번들에 대한 처리 복잡도는 더욱 높아지게 되죠. 명백하게 여기에는 1000개가 넘는 모듈들이 있고 하나의 번들에 모두를 넣는건 불가능합니다. 번들 하나는 오직 몇메가바이트 밖에 안되기 때문입니다. 된다고 하더라도 유저에게 매우 불편함을 줄것입니다.

<center>
<img src="https://miro.medium.com/max/700/1*qZhd4a0S-CCB5mUiN3fo5Q.png"/>
</center>
Slide text: Lazy load at component level?
:.figure

맞습니다. 우리는 라우트 기반 코드 분할만 사용할 수는 없습니다. 다른 방법을 함께 써야합니다. 라우트 기반 코드 분할은 괜찮은 방법이지만 여러분의 응용프로그램을 아주 작은 단위로 분할하면 나중엔 아무 의미가 없어질 것입니다. 저는 간단한 것을 좋아합니다. 라우트 기반의 거친 코드 분할보다 처음부터 세련된 코드 로딩은 없을까요? 만약 우리가 웹사이트의 모든 컴포넌트들을 lazy 로드를 한다면 어떨까요? 여러분이 대역폭에 관한 것만 생각하면 되기 때문에 아주 효과적일 겁니다. 그러나 지연시간의 관점에서는 아주 안좋죠. 그러나 확실히 고려해볼만한 가치가 있을 것입니다.

<center>
<img src="https://miro.medium.com/max/700/1*Lr2hIk4eH9uU33e77zeSmA.png"/>
</center>
Slide text: React component statically depend on their children.
:.figure

예를 들어서 여러분의 서비스가 리액트를 사용하고 있다고 가정해봅시다. 리액트 컴포넌트들은 자식들에게 정적으로 의존합니다. 이 말은 여러분이 children을 lazy 로딩해서 작업을 멈춰야 하는 방식이고 그게 여러분의 프로그래밍 모델을 바꿔야 하는 방식이라면 리액트가 아주 깔끔하게 해결해 준다는 것이죠.

<center>
<img src="https://miro.medium.com/max/700/1*SWkk2vyn344qCNCPSIkXPA.png"/>
</center>
ES6 import example.
:.figure
여러분이 검색 페이지에 통화 변환 컴포넌트를 검색 페이지에 추가한다고 해봅시다. 그럼 여러분은 그걸 임포트 하겠죠? 이게 ES6 모듈에서 작업하는 일반적인 방식입니다.

<center>
<img src="https://miro.medium.com/max/700/1*RxlHaYEav0OaODKYKiUubw.png"/>
</center>
d it, you get code like this where yo
:.figure

그러나 임포트할 때 lazy 로드를 하고 싶다면 동적으로 임포트하는 코드를 사용하셔야 하고 ES6의 lazy 로드 모듈들이 컴포넌트를 lazy load 시켜줍니다. 동적 임포팅을 하는 방식은 500만가지가 더있지만 제가 리액트 전문가는 아니기 때문에 이쯤 하기로 하죠. 제가 하고싶은 말은 이런 것들이 여러분이 코딩을 할 때 영향을 요소라는 것이라는 겁니다.

<center>
<img src="https://miro.medium.com/max/700/1*N5AMAbobPjsO_lXCPt9-ZA.png"/>
</center>
Slide text: Static -> Dynanic
:.figure

그리고 정적인 것들은 이제 너무 구식입니다. 모든게 동적으로 변하고 있고 프로그래밍 모델을 변화시키는 깃발이 되었습니다.

<center>
<img src="https://miro.medium.com/max/700/1*j9OB_yjli59MZMyIs9V0_A.png"/>
</center>
Slide text: Who decides what to lazy load when?
:.figure

그럼 이제 갑자기 이런 의문이 드시겠죠. "누가 대체 무엇을 언제 lazy 로드 하는지 정하는 것일까" 왜냐하면 lazy 로드는 여러분 어플리케이션의 지연시간에 영향을 주기 때문입니다.

<center>
<img src="https://miro.medium.com/max/700/1*rsJ-C7ph0BrJiwTjHKv6_w.png"/>
Slide text: Static or dynamic?
:.figure
</center>

그러면 이제 팀원들은 이런 생각들을 해야합니다. 언제 동적 임포트를해야하고 언제 정적 임포트를 해야하는지 결정해야 하죠. 이런 것이 안좋은 이유는 동적 임포트 되어야 하는 것이 정적으로 임포트 되는 경우 같은 번들에 들어가면 안되는 것들이 갑자기 들어가기 때문입니다. 이런 문제들은 엔지니어가 많을 수록 더 오랜시간 동안 지속 될 것입니다.

<center>
<img src="https://miro.medium.com/max/700/1*QGoX4bYhEAuNjuKwQhQ0hg.png"/>
Slide text: Split logic and rendering
:.figure
</center>

그럼 이제 구글에서 좋은 퍼포먼스를 내면서도 팀원에게 영향을 적게 미치는 좋은 프로그래밍 모델을 사용한 실제 방법에 대해서 말씀 드리겠습니다. 저희가 컴포넌트에 대해서 적용한 방법은 렌더링 로직과 어플리케이션 로직을 분리한 것으로 어플리케이션 로직은 환율 계산 버튼을 누른 것과 같은 이벤트 처리 입니다.

<center>
<img src="https://miro.medium.com/max/700/1*vMskVnAwJgkZmvl4E-8E4Q.png"/>
Slide text: Only load logic if it was rendered.
:.figure
</center>

그래서 이렇게 분리한 로직 중 컴포넌트의 어플리케이션 로직만 렌더링 하기 전에 로딩을 합니다. 이렇게 하면 매우 간단한 모델이 되는데 왜냐하면 간단하게 서버 사이드에서 페이지를 렌더하고 실제로 뭐가 렌더링 되었던간에 연관된 어플리케이션 번들만 다운로드 되기 때문입니다. 이것은 사람이 시스템에 대해서 생각할 필요가 없게 됩니다. 로딩이 렌더링에 따라 자동으로 발생하기 때문입니다.

<center>
<img src="https://miro.medium.com/max/700/1*Doqt-GOkUp13Qgk5r7WR1g.png"/>
Slide text: Currency converter on search result page.
:.figure
</center>

이 방법이 매우 좋아보이지만 역시나 단점도 있습니다. 리액트나 Vue.js와 같은 프레임워크에서 일반적으로 어떻게 서버 렌더링을 하는지 아시나요 hydration 이라는 프로세스를 걸칩니다. 하이드레이션 워크의 동작 방식은 서버 사이드에서 뭔가를 렌더링 하면 그 다음 클라이언트에서 다시 그려야 하는 것으로 이미 페이지에 있는 것을 코드가 로딩 될 때마다 다시 그려야 하는 것입니다. 이것은 코드 로딩이나 실행 두가지 측면에서 매우 큰 낭비입니다. 대역폭과 CPU를 낭비하는 꼴이지만 매우 괜찮습니다. 서버사이드에서 렌더링만 하면 여러분이 클라이언트에서 렌더링 하는 것은 신경꺼도 되기 때문입니다. 그러나 구글에서 사용한 방식은 위와 같은 방식이 아닙니다. 따라서 여러분이 아주 큰 응용프로그램을 설계한다면 이런 것들을 꼭 고려하셔야 합니다. 좀더 복잡하게 해서 매우 빠르게 할 것인가, 아니면 덜 효율적이지만 하이드레이션을 써서 좋은 프로그래밍 모델을 가져갈 것인가, 여러분은 이런 결정을 하시게 될 겁니다.

## Summary
*
